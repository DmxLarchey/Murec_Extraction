diff --git a/theories/compute.v b/theories/compute.v
deleted file mode 100644
index d2b48b6..0000000
--- a/theories/compute.v
+++ /dev/null
@@ -1,107 +0,0 @@
-(**************************************************************)
-(*   Copyright Dominique Larchey-Wendling    [*]              *)
-(*             Jean-FranÃ§ois Monin           [+]              *)
-(*                                                            *)
-(*           [*] Affiliation Univ. Lorraine - CNRS - LORIA    *)
-(*           [+] Affiliation VERIMAG - Univ. Grenoble Alpes   *)
-(**************************************************************)
-(*      This file is distributed under the terms of the       *)
-(*        CeCILL v2.1 FREE SOFTWARE LICENSE AGREEMENT         *)
-(**************************************************************)
-
-From Coq Require Import Utf8.
-
-From MuRec Require Import sigma schemes index vec recalg recalg_semantics.
-From MuRec Require Export compute_def map_compute prim_rec_compute umin_compute.
-
-Definition Zr_compute V1 : compute (Zr V1) := Î» _, âŸª0, eq_reflâŸ«.
-Definition Sc_compute : âˆ€V1, compute (Sc V1) := vec_S_inv (Î» x _ _, âŸªS x, eq_reflâŸ«).
-Definition Id_compute {a} (i : idx a) Va : compute (Id i Va) := Î» _, âŸªVa.[i], eq_reflâŸ«.
-
-Section Cn_compute.
-
-  Variables (a b : nat)
-            (Sb : recalg b)
-            (cSb : âˆ€Vb, compute (âŸ¦SbâŸ§ Vb))
-            (Sab : vec (recalg a) b)
-            (cSab : âˆ€Va, compute (Î» Vb, âˆ€i, âŸ¦Sab.[i]âŸ§ Va Vb.[i])).
-
-  Section Cn_props.
-
-    Variables (Va : vec nat a) (cVa : ex (Cn âŸ¦SbâŸ§ (vec_map ra_sem Sab) Va)).
-
-    Local Fact Cn_p1 : âˆƒVb, âˆ€i, âŸ¦Sab.[i]âŸ§ Va Vb.[i].
-    Proof.
-      destruct cVa as (y & Vb & H1 & H2).
-      exists Vb; intros i.
-      specialize (H2 i).
-      now rewrite vec_prj_map in H2.
-    Qed.
-
-    Variables (Vb : vec nat b) (HVb : âˆ€i, âŸ¦Sab.[i]âŸ§ Va Vb.[i]).
-
-    Fact Cn_p2 : âˆƒy, âŸ¦SbâŸ§ Vb y.
-    Proof.
-      destruct cVa as (y & Wb & H1 & H2).
-      exists y.
-      replace Vb with Wb; trivial.
-      apply vec_prj_ext; intros i.
-      specialize (H2 i); specialize (HVb i).
-      rewrite vec_prj_map in H2.
-      revert H2 HVb; apply ra_sem_fun.
-    Qed.
-
-    Variables (y : nat) (Hy : âŸ¦SbâŸ§ Vb y).
-
-    Fact Cn_p3 : âŸ¦ra_comp Sb SabâŸ§ Va y.
-    Proof.
-      exists Vb; refine (conj Hy _).
-      intro; now rewrite vec_prj_map.
-    Qed.
-
-  End Cn_props.
-
-  Arguments Cn_p1 {_}.
-  Arguments Cn_p2 {_} _ {_} _.
-  Arguments Cn_p3 {_} {_} _ {_}.
-
-  Definition Cn_compute : âˆ€Va, compute (Cn âŸ¦SbâŸ§ (vec_map ra_sem Sab) Va) :=
-    Î» Va cVa, let (Vb,cVb) := cSab Va (Cn_p1 cVa) in
-              let (y,cy)   := cSb Vb (Cn_p2 cVa cVb) in
-              âŸªy, Cn_p3 cVb cyâŸ«.
-
-End Cn_compute.
-
-Arguments Cn_compute {a b Sb} _ {Sab} _.
-
-Section Pr_compute.
-
-  Variables (a : nat)
-            (Sa : recalg a)       (cSa : âˆ€Va, compute (âŸ¦SaâŸ§ Va))
-            (Sa'' : recalg (2+a)) (cSa'' : âˆ€Va'', compute (âŸ¦Sa''âŸ§ Va'')).
-
-  Definition Pr_compute : âˆ€Va', compute (Pr âŸ¦SaâŸ§ âŸ¦Sa''âŸ§ Va') :=
-    vec_S_inv (Î» z Va,
-      prim_rec_compute (ra_sem_fun _)
-                       (Î» V cV, cSa V cV)
-                       (Î» _ _ _, ra_sem_fun _ _)
-                       (Î» V n x cVnx, cSa'' (n âˆ· x âˆ· V) cVnx)
-                       Va
-                       z
-    ).
-
-End Pr_compute.
-
-Arguments Pr_compute {a} {Sa} cSa {Sa''} cSa''.
-
-Section Mn_compute.
-
-  Variables (a : nat) (Sa' : recalg (1+a)) (cSa' : âˆ€Va', compute (âŸ¦Sa'âŸ§ Va')).
-
-  Definition Mn_compute Va : compute (Mn âŸ¦Sa'âŸ§ Va) :=
-    uminâ‚€_compute (Î» _, ra_sem_fun _ _)
-                  (Î» n cn, cSa' (n âˆ· Va) cn).
-
-End Mn_compute.
-
-Arguments Mn_compute {a} {Sa'} cSa'.
diff --git a/theories/compute_def.v b/theories/compute_def.v
deleted file mode 100644
index 6389fd8..0000000
--- a/theories/compute_def.v
+++ /dev/null
@@ -1,18 +0,0 @@
-(**************************************************************)
-(*   Copyright Dominique Larchey-Wendling    [*]              *)
-(*             Jean-FranÃ§ois Monin           [+]              *)
-(*                                                            *)
-(*           [*] Affiliation Univ. Lorraine - CNRS - LORIA    *)
-(*           [+] Affiliation VERIMAG - Univ. Grenoble Alpes   *)
-(**************************************************************)
-(*      This file is distributed under the terms of the       *)
-(*        CeCILL v2.1 FREE SOFTWARE LICENSE AGREEMENT         *)
-(**************************************************************)
-
-From Coq Require Import Utf8.
-
-(** A predicate "computes" if a value in it can be computed 
-    using of a proof of its inhabitation has termination
-    certificate *)
-
-Definition compute {X} (P : X â†’ Prop) := ex P â†’ sig P.
diff --git a/theories/interpreter.v b/theories/interpreter.v
index cf4fc91..d19436e 100644
--- a/theories/interpreter.v
+++ b/theories/interpreter.v
@@ -12,7 +12,7 @@
 From Coq Require Import Utf8 Extraction.
 
 From MuRec Require Import sigma relations arith_mini index vec
-                          recalg recalg_semantics compute.
+                          recalg recalg_semantics computable.
 
 Reserved Notation " 'âŸ¦' f 'âŸ§â‚’' " (at level 1, format "âŸ¦ f âŸ§â‚’").
 
@@ -25,7 +25,7 @@ Section recalg_coq.
      of the algorithm Sa as a combination of Âµ-recursive
      schemes *)
 
-  (* We show that the graph âŸ¦SaâŸ§ computes for any
+  (* We show that the graph âŸ¦SaâŸ§ is computable for any
      Sa : recalg a, ie it can be reified into a Coq term
 
          âˆ€Va : vec nat a, ex (âŸ¦SaâŸ§ Va) â†’ sig (âŸ¦SaâŸ§ Va)
@@ -62,12 +62,12 @@ Section recalg_coq.
        ra_compute and Cn_compute at Extraction, which generates
        a fresh new name like "sa0", not so nice at display *)
 
-  Fixpoint ra_compute {k} (Sk : recalg k) { struct Sk } : âˆ€Vk : vec nat k, compute (âŸ¦SkâŸ§ Vk) :=
+  Fixpoint ra_compute {k} (Sk : recalg k) { struct Sk } : âˆ€Vk : vec nat k, computable (âŸ¦SkâŸ§ Vk) :=
     match Sk with
     | ra_zero         => Zr_compute
     | ra_succ         => Sc_compute
     | ra_proj i       => Id_compute i
-    | ra_comp Sb Sab  => Cn_compute âŸ¦SbâŸ§â‚’ (Î» Va cVa, vec_map_compute (Î» Sa, âŸ¦SaâŸ§â‚’ Va) Sab cVa)
+    | ra_comp Sb Sab  => Cn_compute âŸ¦SbâŸ§â‚’ (Î» Va cVa, vec_map_compute (Î» Sa cSa, âŸ¦SaâŸ§â‚’ Va (Ï€áµ¤ cSa)) Sab cVa)
     | ra_prec Sb Sb'' => Pr_compute âŸ¦SbâŸ§â‚’ âŸ¦Sb''âŸ§â‚’
     | ra_umin Sb'     => Mn_compute âŸ¦Sb'âŸ§â‚’
     end
@@ -113,6 +113,9 @@ Extraction Inline sig_monotonic comp reify.
 Extraction Inline uminâ‚€_compute.
 Extraction Inline Id_compute Zr_compute Sc_compute Pr_compute Mn_compute Cn_compute.
 
+(* unit is extracted as unit () *)
+Extract Inductive unit => "unit" [ "()" ].
+
 (* indices extracted as (unbounded) nat *)
 Extract Inductive idx => "nat" [ "O" "S" ].
 
diff --git a/theories/linear_search.v b/theories/linear_search.v
index 2cb83fd..c233849 100644
--- a/theories/linear_search.v
+++ b/theories/linear_search.v
@@ -90,9 +90,7 @@ Section linear_search.
     exact @ğ”»ls_next.
   Qed.
 
-  (* test is specified by âˆ€n, Dtest n â†’ {P n} + {Q n}
-     so it is possible that neither P nor Q hold outside of Dtest *)
-  Variable test : âˆ€n, Dtest n â†’ {P n} + {Q n}.
+  Variable test : âˆ€n, {_ : unit | Dtest n} â†’ {P n} + {Q n}.
 
   (* loop_â„• : âˆ€n, ğ”»ls n â†’ nat
 
@@ -104,7 +102,7 @@ Section linear_search.
      Notice that it is a "recursive terminal" function. *)
 
   Local Fixpoint loop_â„• n (d : ğ”»ls n) : nat :=
-    match test n (ğ”»ls_Ï€â‚ d) with
+    match test n âŒŠğ”»ls_Ï€â‚ dâŒ‹áµ¤ with
     | left p  => n
     | right q => loop_â„• (S n) (ğ”»ls_Ï€â‚‚ d q)
     end.
@@ -125,7 +123,7 @@ Section linear_search.
 
   Let Fixpoint loop n (d : ğ”»ls n) (b : btwn (Dtest âˆ§â‚ Q) s n) : sig (â„™ost_ls s) :=
     let t := ğ”»ls_Ï€â‚ d in
-    match test n t with
+    match test n âŒŠtâŒ‹áµ¤ with
     | left p  => âŸªn, âŸ¨t,p, bâŸ©â‚šâŸ«
     | right q => loop (S n) (ğ”»ls_Ï€â‚‚ d q) (btwn_next b âŸ¨t,qâŸ©â‚š)
     end.
diff --git a/theories/map_compute.v b/theories/map_compute.v
index 4081d24..31036bf 100644
--- a/theories/map_compute.v
+++ b/theories/map_compute.v
@@ -11,13 +11,13 @@
 
 From Coq Require Import Utf8.
 
-From MuRec Require Import sigma relations index vec compute_def.
+From MuRec Require Import sigma relations index vec computable_def.
 
 Section vec_map_compute.
 
   Variables (X Y : Type)
             (F : X â†’ Y â†’ Prop)
-            (f : âˆ€ x, compute (F x)).
+            (f : âˆ€ x, computableáµ¤ (F x)).
 
   Section vec_map_compute_props.
 
@@ -37,11 +37,11 @@ Section vec_map_compute.
 
   Arguments vmc_PO2 {_ _ _ _ _}.
 
-  Definition vec_map_compute : âˆ€{n} (v : vec X n), compute (Î» w, âˆ€i, F v.[i] w.[i]) :=
+  Definition vec_map_compute : âˆ€{n} (v : vec X n), computable (Î» w, âˆ€i, F v.[i] w.[i]) :=
     let fix loop {n} (v : vec X n) : (âˆ€i, ex (F v.[i])) â†’ _ :=
       match v with
       | âŸ¨âŸ©    => Î» _,   âŸªâŸ¨âŸ©, vmc_PO1âŸ«
-      | x âˆ· v => Î» Fxv, let (y, x_y) := f x (Fxv ğ•†) in
+      | x âˆ· v => Î» Fxv, let (y, x_y) := f x âŒŠFxv ğ•†âŒ‹áµ¤ in
                         let (w, v_w) := loop v (Î» i, Fxv (ğ•Š i)) in
                         âŸªy âˆ· w, vmc_PO2 x_y v_wâŸ«
       end in
diff --git a/theories/prim_rec_compute.v b/theories/prim_rec_compute.v
index 1fb7ffe..c68fbde 100644
--- a/theories/prim_rec_compute.v
+++ b/theories/prim_rec_compute.v
@@ -11,17 +11,17 @@
 
 From Coq Require Import Utf8.
 
-From MuRec Require Import sigma relations schemes compute_def.
+From MuRec Require Import sigma relations schemes computable_def.
 
 Section prec_compute.
 
   Variables (X Y : Type)
             (F : X â†’ Y â†’ Prop)
             (Ffun : functional F)
-            (Fcomp : âˆ€x, compute (F x))
+            (Fcomp : âˆ€x, computableáµ¤ (F x))
             (G : X â†’ nat â†’ Y â†’ Y â†’ Prop)
             (Gfun : âˆ€ x n, functional (G x n))
-            (Gcomp : âˆ€ x n y, compute (G x n y))
+            (Gcomp : âˆ€ x n y, computableáµ¤ (G x n y))
             (x : X).
 
   Section prim_rec_compute_props.
@@ -54,11 +54,11 @@ Section prec_compute.
   Arguments prc_TC2 {_} _ {_} _.
   Arguments prc_PO1 {_ _} _ {_} _.
 
-  Fixpoint prim_rec_compute m : compute (prim_rec F G x m) :=
+  Fixpoint prim_rec_compute m : computable (prim_rec F G x m) :=
     match m with
-      | 0   => Î» e, Fcomp x e
+      | 0   => Î» e, Fcomp x âŒŠeâŒ‹áµ¤
       | S n => Î» e, let (yn , y_yn)   := prim_rec_compute n (prc_TC1 e) in
-                    let (yn', yn_yn') := Gcomp x n yn (prc_TC2 e y_yn) in
+                    let (yn', yn_yn') := Gcomp x n yn âŒŠprc_TC2 e y_ynâŒ‹áµ¤ in
                     âŸªyn', prc_PO1 y_yn yn_yn'âŸ«
     end.
 
diff --git a/theories/sigma.v b/theories/sigma.v
index 84c46a6..fa53c52 100644
--- a/theories/sigma.v
+++ b/theories/sigma.v
@@ -21,6 +21,9 @@ Notation "âŸª x , h âŸ«" := (exist _ x h) (at level 0, format "âŸª x ,  h âŸ«").
 Notation Ï€â‚ := proj1_sig.
 Notation Ï€â‚‚ := proj2_sig.
 
+Notation "'âŒŠ' P 'âŒ‹áµ¤'" := (exist _ tt P) (at level 1, format "âŒŠ P âŒ‹áµ¤").
+Notation Ï€áµ¤ := proj2_sig.
+
 Definition reify {X Y} {P : X â†’ Y â†’ Prop} : (âˆ€ x, { y | P x y }) â†’ { f : X â†’ Y | âˆ€ x, P x (f x) } :=
   Î» df, exist (Î» f, âˆ€ x, P x (f x)) (Î» x, Ï€â‚ (df x)) (Î» x, Ï€â‚‚ (df x)).
 
diff --git a/theories/umin_compute.v b/theories/umin_compute.v
index 60b2a16..762d487 100644
--- a/theories/umin_compute.v
+++ b/theories/umin_compute.v
@@ -11,13 +11,13 @@
 
 From Coq Require Import Utf8.
 
-From MuRec Require Import sigma relations arith_mini between schemes compute_def linear_search.
+From MuRec Require Import sigma relations arith_mini between schemes computable_def linear_search.
 
 Section umin_compute.
 
   Variable (F : nat â†’ nat â†’ Prop)
            (Ffun : functional F)
-           (f : âˆ€n, compute (F n)).
+           (f : âˆ€n, computableáµ¤ (F n)).
 
   Arguments Ffun {_ _ _}.
 
@@ -42,7 +42,7 @@ Section umin_compute.
   (* The algorithm below can be derived from the one in linear_search.v.
      umin F s, that is ze_at F âˆ§â‚ btwn (pos_at F) s, is at the same time the
      pre and the post-condition of the intended algorithm (umin_compute), by
-     the definition of compute.
+     the definition of computable.
      It is also an opportunistic version of â„™ost.
      See umin_compute_details.v for details. *)
   (* ---------------------------------------------------------------------- *)
@@ -50,7 +50,7 @@ Section umin_compute.
   (* The Let before the Fixpoint below forces the inlining of loop inside
      linear_search *)
   Let Fixpoint loop n (d : ğ”» n) (b : btwn (pos_at F) s n) : sig (umin F s) :=
-    let (k,Hk) := f n (ğ”»_Ï€â‚ d) in
+    let (k,Hk) := f n âŒŠğ”»_Ï€â‚ dâŒ‹áµ¤ in
     match k return F _ k â†’ _ with
     | 0   => Î» e, âŸªn, âŸ¨e,bâŸ©â‚šâŸ«
     | S _ => Î» e, loop (S n) (ğ”»_Ï€â‚‚ d âŸª_,eâŸ«â‚š) (btwn_next b âŸª_,eâŸ«â‚š)
@@ -71,7 +71,7 @@ Section umin_compute.
     - apply pos_at_def_at.
   Qed.
 
-  Definition umin_compute : compute (umin F s) :=
+  Definition umin_compute : computable (umin F s) :=
     linear_search  âˆ˜  ex_monotonic umin_â„™re.
 
 End umin_compute.
@@ -82,9 +82,9 @@ Section uminâ‚€_compute.
 
   Variable (F : nat â†’ nat â†’ Prop)
            (Ffun : functional F)
-           (f : âˆ€n, compute (F n)).
+           (f : âˆ€n, computableáµ¤ (F n)).
 
-  Definition uminâ‚€_compute : compute (uminâ‚€ F) :=
+  Definition uminâ‚€_compute : computable (uminâ‚€ F) :=
     sig_monotonic umin_uminâ‚€  âˆ˜  umin_compute Ffun f 0  âˆ˜  ex_monotonic uminâ‚€_umin.
 
 End uminâ‚€_compute.
diff --git a/theories/umin_compute_details.v b/theories/umin_compute_details.v
index 3783ae6..0ebeb9b 100644
--- a/theories/umin_compute_details.v
+++ b/theories/umin_compute_details.v
@@ -11,13 +11,13 @@
 
 From Coq Require Import Utf8.
 
-From MuRec Require Import sigma relations arith_mini between schemes compute_def linear_search.
+From MuRec Require Import sigma relations arith_mini between schemes computable_def linear_search.
 
 Section umin_compute.
 
   Variable (F : nat â†’ nat â†’ Prop)
            (Ffun : functional F)
-           (f : âˆ€n, compute (F n)).
+           (f : âˆ€n, computableáµ¤ (F n)).
 
   Arguments Ffun {_ _ _}.
 
@@ -43,7 +43,7 @@ Section umin_compute.
 
   (* Instanciation of test *)
   Let test n (t : Dtest n) : {P n} + {Q n} :=
-    let (k, Hk) := f n t in
+    let (k, Hk) := f n âŒŠtâŒ‹áµ¤ in
     match k return F _ k â†’ _ with
     | 0   => Î» e, left e
     | S k => Î» e, right âŸªk,eâŸ«â‚š
@@ -60,7 +60,7 @@ Section umin_compute.
   (* Inlining the current instance of test inside loop_orig *)
   Local Fixpoint loop_inline n (d : ğ”» n) (b : btwn (Dtest âˆ§â‚ Q) s n) : sig (â„™ost s) :=
     let t := ğ”»_Ï€â‚ d in
-    let (k, Hk) := f n t in
+    let (k, Hk) := f n âŒŠtâŒ‹áµ¤ in
     let te := match k return F _ k â†’ _ with
               | 0   => Î» e, left e
               | S k => Î» e, right âŸª_,eâŸ«â‚š
@@ -73,7 +73,7 @@ Section umin_compute.
   (* Easy program transformation: the intermediate te is bypassed *)
   Local Fixpoint loop_opt n (d : ğ”» n) (b : btwn (Dtest âˆ§â‚ Q) s n) : sig (â„™ost s) :=
     let t := ğ”»_Ï€â‚ d in
-    let (k, Hk) := f n t in
+    let (k, Hk) := f n âŒŠtâŒ‹áµ¤ in
     match k return F _ k â†’ _ with
     | 0   => Î» e, âŸªn, âŸ¨t,e, bâŸ©â‚šâŸ«
     | S k => Î» e, loop_opt (S n) (ğ”»_Ï€â‚‚ d âŸª_,eâŸ«â‚š) (btwn_next b âŸ¨t, âŸª_,eâŸ«â‚šâŸ©â‚š)
@@ -91,13 +91,13 @@ Section umin_compute.
 
      This simplified version of the post-condition happens to be identical to
      umin F s, which is at the same time the pre and the post-condition of the
-     intended algorithm (umin_compute), by the very definition of compute.
+     intended algorithm (umin_compute), by the very definition of computable.
   *)
 
   (* The Let before the Fixpoint below forces the inlining of loop inside
      linear_search *)
   Let Fixpoint loop n (d : ğ”» n) (b : btwn (pos_at F) s n) : sig (umin F s) :=
-    let (k,Hk) := f n (ğ”»_Ï€â‚ d) in
+    let (k,Hk) := f n âŒŠğ”»_Ï€â‚ dâŒ‹áµ¤ in
     match k return F _ k â†’ _ with
     | 0   => Î» e, âŸªn, âŸ¨e,bâŸ©â‚šâŸ«
     | S _ => Î» e, loop (S n) (ğ”»_Ï€â‚‚ d âŸª_,eâŸ«â‚š) (btwn_next b âŸª_,eâŸ«â‚š)
@@ -121,7 +121,7 @@ Section umin_compute.
     - apply pos_at_def_at.
   Qed.
 
-  Definition umin_compute : compute (umin F s) :=
+  Definition umin_compute : computable (umin F s) :=
     linear_search  âˆ˜  ex_monotonic umin_â„™re.
 
 End umin_compute.
@@ -132,9 +132,9 @@ Section uminâ‚€_compute.
 
   Variable (F : nat â†’ nat â†’ Prop)
            (Ffun : functional F)
-           (f : âˆ€n, compute (F n)).
+           (f : âˆ€n, computableáµ¤ (F n)).
 
-  Definition uminâ‚€_compute : compute (uminâ‚€ F) :=
+  Definition uminâ‚€_compute : computable (uminâ‚€ F) :=
     sig_monotonic umin_uminâ‚€  âˆ˜  umin_compute Ffun f 0  âˆ˜  ex_monotonic uminâ‚€_umin.
 
 End uminâ‚€_compute.
