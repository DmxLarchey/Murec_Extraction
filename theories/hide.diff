diff --git a/theories/compute.v b/theories/compute.v
index ee4b4e1..d9bb074 100644
--- a/theories/compute.v
+++ b/theories/compute.v
@@ -83,9 +83,9 @@ Section Pr_compute.
   Definition Pr_compute : âˆ€Va', compute (Pr âŸ¦SaâŸ§ âŸ¦Sa''âŸ§ Va') :=
     vec_S_inv (Î» z Va,
       prim_rec_compute (ra_sem_fun _)
-                       (Î» V dV, cSa V dV)
+                       (Î» p, cSa (Ï€â‚ p) (Ï€â‚‚ p))
                        (Î» _ _ _, ra_sem_fun _ _)
-                       (Î» V n x cVnx, cSa'' (n âˆ· x âˆ· V) cVnx)
+                       (Î» V n x, cSa'' (n âˆ· Ï€â‚ x âˆ· V) (Ï€â‚‚ x))
                        Va
                        z
     ).
@@ -100,7 +100,7 @@ Section Mn_compute.
 
   Definition Mn_compute Va : compute (Mn âŸ¦Sa'âŸ§ Va) :=
     uminâ‚€_compute (Î» _, ra_sem_fun _ _)
-                  (Î» n dn, cSa' (n âˆ· Va) dn).
+                  (Î» p, cSa' (Ï€â‚ p âˆ· Va) (Ï€â‚‚ p)).
 
 End Mn_compute.
 
diff --git a/theories/interpreter.v b/theories/interpreter.v
index 1f7f63e..61c778c 100644
--- a/theories/interpreter.v
+++ b/theories/interpreter.v
@@ -59,7 +59,7 @@ Section recalg_coq.
     | ra_zero         => Zr_compute
     | ra_succ         => Sc_compute
     | ra_proj i       => Id_compute i
-    | ra_comp Sb Sab  => Cn_compute âŸ¦SbâŸ§â‚’ (Î» Va dVa, vec_map_compute (Î» Sa, âŸ¦SaâŸ§â‚’ Va) Sab dVa)
+    | ra_comp Sb Sab  => Cn_compute âŸ¦SbâŸ§â‚’ (Î» Va dVa, vec_map_compute (Î» x, âŸ¦xâŸ§ Va) (Î» p, âŸ¦Ï€â‚ pâŸ§â‚’ Va (Ï€â‚‚ p)) Sab dVa)
     | ra_prec Sb Sb'' => Pr_compute âŸ¦SbâŸ§â‚’ âŸ¦Sb''âŸ§â‚’
     | ra_umin Sb'     => Mn_compute âŸ¦Sb'âŸ§â‚’
     end
diff --git a/theories/linear_search.v b/theories/linear_search.v
index 2cb83fd..ba918c4 100644
--- a/theories/linear_search.v
+++ b/theories/linear_search.v
@@ -90,9 +90,7 @@ Section linear_search.
     exact @ğ”»ls_next.
   Qed.
 
-  (* test is specified by âˆ€n, Dtest n â†’ {P n} + {Q n}
-     so it is possible that neither P nor Q hold outside of Dtest *)
-  Variable test : âˆ€n, Dtest n â†’ {P n} + {Q n}.
+  Variable test : âˆ€p : { n | Dtest n }, {P (Ï€â‚ p)} + {Q (Ï€â‚ p)}.
 
   (* loop_â„• : âˆ€n, ğ”»ls n â†’ nat
 
@@ -104,7 +102,7 @@ Section linear_search.
      Notice that it is a "recursive terminal" function. *)
 
   Local Fixpoint loop_â„• n (d : ğ”»ls n) : nat :=
-    match test n (ğ”»ls_Ï€â‚ d) with
+    match test âŸªn,ğ”»ls_Ï€â‚ dâŸ« with
     | left p  => n
     | right q => loop_â„• (S n) (ğ”»ls_Ï€â‚‚ d q)
     end.
@@ -125,7 +123,7 @@ Section linear_search.
 
   Let Fixpoint loop n (d : ğ”»ls n) (b : btwn (Dtest âˆ§â‚ Q) s n) : sig (â„™ost_ls s) :=
     let t := ğ”»ls_Ï€â‚ d in
-    match test n t with
+    match test âŸªn,tâŸ« with
     | left p  => âŸªn, âŸ¨t,p, bâŸ©â‚šâŸ«
     | right q => loop (S n) (ğ”»ls_Ï€â‚‚ d q) (btwn_next b âŸ¨t,qâŸ©â‚š)
     end.
diff --git a/theories/map_compute.v b/theories/map_compute.v
index 4081d24..f49607b 100644
--- a/theories/map_compute.v
+++ b/theories/map_compute.v
@@ -17,7 +17,7 @@ Section vec_map_compute.
 
   Variables (X Y : Type)
             (F : X â†’ Y â†’ Prop)
-            (f : âˆ€ x, compute (F x)).
+            (f : âˆ€ p : { x | ex (F x) }, sig (F (Ï€â‚ p))).
 
   Section vec_map_compute_props.
 
@@ -41,7 +41,7 @@ Section vec_map_compute.
     let fix loop {n} (v : vec X n) : (âˆ€i, ex (F v.[i])) â†’ _ :=
       match v with
       | âŸ¨âŸ©    => Î» _,   âŸªâŸ¨âŸ©, vmc_PO1âŸ«
-      | x âˆ· v => Î» Fxv, let (y, x_y) := f x (Fxv ğ•†) in
+      | x âˆ· v => Î» Fxv, let (y, x_y) := f âŸªx,Fxv ğ•†âŸ« in
                         let (w, v_w) := loop v (Î» i, Fxv (ğ•Š i)) in
                         âŸªy âˆ· w, vmc_PO2 x_y v_wâŸ«
       end in
@@ -49,5 +49,5 @@ Section vec_map_compute.
 
 End vec_map_compute.
 
-Arguments vec_map_compute {_ _ _} _ {n} v.
+Arguments vec_map_compute {_ _} _ _ {n} v.
 
diff --git a/theories/prim_rec_compute.v b/theories/prim_rec_compute.v
index 5095ac1..5f449c3 100644
--- a/theories/prim_rec_compute.v
+++ b/theories/prim_rec_compute.v
@@ -18,10 +18,10 @@ Section prec_compute.
   Variables (X Y : Type)
             (F : X â†’ Y â†’ Prop)
             (Ffun : functional F)
-            (Fcomp : âˆ€x, compute (F x))
+            (Fcomp : âˆ€ p : { x | ex (F x) }, sig (F (Ï€â‚ p)))
             (G : X â†’ nat â†’ Y â†’ Y â†’ Prop)
             (Gfun : âˆ€ x n, functional (G x n))
-            (Gcomp : âˆ€ x n y, compute (G x n y))
+            (Gcomp : âˆ€ x n (p : { y | ex (G x n y) }), sig (G x n (Ï€â‚ p)))
             (x : X).
 
   Section prim_rec_compute_props.
@@ -56,9 +56,9 @@ Section prec_compute.
 
   Fixpoint prim_rec_compute m : compute (prim_rec F G x m) :=
     match m with
-      | 0   => Î» d, Fcomp x d
+      | 0   => Î» d, Fcomp âŸªx,dâŸ«
       | S n => Î» d, let (yn , y_yn)   := prim_rec_compute n (prc_TC1 d) in
-                    let (yn', yn_yn') := Gcomp x n yn (prc_TC2 d y_yn) in
+                    let (yn', yn_yn') := Gcomp x n âŸªyn,prc_TC2 d y_ynâŸ« in
                     âŸªyn', prc_PO1 y_yn yn_yn'âŸ«
     end.
 
diff --git a/theories/umin_compute.v b/theories/umin_compute.v
index 60b2a16..2428cfe 100644
--- a/theories/umin_compute.v
+++ b/theories/umin_compute.v
@@ -17,7 +17,7 @@ Section umin_compute.
 
   Variable (F : nat â†’ nat â†’ Prop)
            (Ffun : functional F)
-           (f : âˆ€n, compute (F n)).
+           (f : âˆ€ p : { n | ex (F n) }, sig (F (Ï€â‚ p))).
 
   Arguments Ffun {_ _ _}.
 
@@ -50,7 +50,7 @@ Section umin_compute.
   (* The Let before the Fixpoint below forces the inlining of loop inside
      linear_search *)
   Let Fixpoint loop n (d : ğ”» n) (b : btwn (pos_at F) s n) : sig (umin F s) :=
-    let (k,Hk) := f n (ğ”»_Ï€â‚ d) in
+    let (k,Hk) := f âŸªn,ğ”»_Ï€â‚ dâŸ« in
     match k return F _ k â†’ _ with
     | 0   => Î» e, âŸªn, âŸ¨e,bâŸ©â‚šâŸ«
     | S _ => Î» e, loop (S n) (ğ”»_Ï€â‚‚ d âŸª_,eâŸ«â‚š) (btwn_next b âŸª_,eâŸ«â‚š)
@@ -82,7 +82,7 @@ Section uminâ‚€_compute.
 
   Variable (F : nat â†’ nat â†’ Prop)
            (Ffun : functional F)
-           (f : âˆ€n, compute (F n)).
+           (f : âˆ€ p : { n | ex (F n) }, sig (F (Ï€â‚ p))).
 
   Definition uminâ‚€_compute : compute (uminâ‚€ F) :=
     sig_monotonic umin_uminâ‚€  âˆ˜  umin_compute Ffun f 0  âˆ˜  ex_monotonic uminâ‚€_umin.
diff --git a/theories/umin_compute_details.v b/theories/umin_compute_details.v
index 3783ae6..673a730 100644
--- a/theories/umin_compute_details.v
+++ b/theories/umin_compute_details.v
@@ -17,7 +17,7 @@ Section umin_compute.
 
   Variable (F : nat â†’ nat â†’ Prop)
            (Ffun : functional F)
-           (f : âˆ€n, compute (F n)).
+           (f : âˆ€ p : { n | ex (F n) }, sig (F (Ï€â‚ p))).
 
   Arguments Ffun {_ _ _}.
 
@@ -43,7 +43,7 @@ Section umin_compute.
 
   (* Instanciation of test *)
   Let test n (t : Dtest n) : {P n} + {Q n} :=
-    let (k, Hk) := f n t in
+    let (k, Hk) := f âŸªn,tâŸ« in
     match k return F _ k â†’ _ with
     | 0   => Î» e, left e
     | S k => Î» e, right âŸªk,eâŸ«â‚š
@@ -60,7 +60,7 @@ Section umin_compute.
   (* Inlining the current instance of test inside loop_orig *)
   Local Fixpoint loop_inline n (d : ğ”» n) (b : btwn (Dtest âˆ§â‚ Q) s n) : sig (â„™ost s) :=
     let t := ğ”»_Ï€â‚ d in
-    let (k, Hk) := f n t in
+    let (k, Hk) := f âŸªn,tâŸ« in
     let te := match k return F _ k â†’ _ with
               | 0   => Î» e, left e
               | S k => Î» e, right âŸª_,eâŸ«â‚š
@@ -73,7 +73,7 @@ Section umin_compute.
   (* Easy program transformation: the intermediate te is bypassed *)
   Local Fixpoint loop_opt n (d : ğ”» n) (b : btwn (Dtest âˆ§â‚ Q) s n) : sig (â„™ost s) :=
     let t := ğ”»_Ï€â‚ d in
-    let (k, Hk) := f n t in
+    let (k, Hk) := f âŸªn,tâŸ« in
     match k return F _ k â†’ _ with
     | 0   => Î» e, âŸªn, âŸ¨t,e, bâŸ©â‚šâŸ«
     | S k => Î» e, loop_opt (S n) (ğ”»_Ï€â‚‚ d âŸª_,eâŸ«â‚š) (btwn_next b âŸ¨t, âŸª_,eâŸ«â‚šâŸ©â‚š)
@@ -97,7 +97,7 @@ Section umin_compute.
   (* The Let before the Fixpoint below forces the inlining of loop inside
      linear_search *)
   Let Fixpoint loop n (d : ğ”» n) (b : btwn (pos_at F) s n) : sig (umin F s) :=
-    let (k,Hk) := f n (ğ”»_Ï€â‚ d) in
+    let (k,Hk) := f âŸªn,ğ”»_Ï€â‚ dâŸ« in
     match k return F _ k â†’ _ with
     | 0   => Î» e, âŸªn, âŸ¨e,bâŸ©â‚šâŸ«
     | S _ => Î» e, loop (S n) (ğ”»_Ï€â‚‚ d âŸª_,eâŸ«â‚š) (btwn_next b âŸª_,eâŸ«â‚š)
@@ -132,7 +132,7 @@ Section uminâ‚€_compute.
 
   Variable (F : nat â†’ nat â†’ Prop)
            (Ffun : functional F)
-           (f : âˆ€n, compute (F n)).
+           (f : âˆ€ p : { n | ex (F n) }, sig (F (Ï€â‚ p))).
 
   Definition uminâ‚€_compute : compute (uminâ‚€ F) :=
     sig_monotonic umin_uminâ‚€  âˆ˜  umin_compute Ffun f 0  âˆ˜  ex_monotonic uminâ‚€_umin.
